# Database mapper from scratch

This database mapper is written for sqlx database library, mainly supporting postgres. It aims to be as lightweight as possible.

## TO DO

* has many

## In Scope

* maintains a database connection
* provides logrus logging
* provides health report on the connection
* provides basic query functionality on top of sqlx for logging purposes
* provides basic model query functionality (Find, FindBy, All, Create, Update, Delete)
* provides basic "belongs to", "has one" relationships

## Out of Scope

* Transactions (for now)
* Cascading joins in select: all joins are referencing the original model only.

## Map models

Models are structs, and mapper reads their "db" tags for meta-information. Some rules:

- Database table names are generated by struct names by converting to lower-cased, pluralized form. No snake-casing is taking place.
- Empty `db:"..."` tag names are not handled well. If there is a tag, it must be named.
- if the tag is "-" (just like in `db:"-"`), then that field will not be represented in the database
- if the tag is missing, sqlx uses a standard mapping: field name converted to lower case, and never `snake_case`.
- mapper accepts the following tag options (optional fields after a comma):
    - omitempty: if the field is empty in the model, it won't be added to Create / Update query
    - relation: it represents "has one" or "has many" relationships (depending on the field type)
    - belongs: represents "belongs_to" relationship. It assumes another field with the same name, but with `_id` suffix.
    - related maps can and should be added to structs. To avoid circular references, use pointers for related structs.

## Relations

### Belongs

When a struct "belongs to" another struct, it stores the other struct's ID like this:

```golang
type Message struct {
    ID    int
    Title string
    Body  string
}

type Comment struct {
    ID     int
    Title  string
    Body   string
    PostID int     `db:"post_id"`
    Post   Message `db:"post,belongs"`
}
```

In this case, Comment belongs to Message, and it's referenced internally as "post". It also requires a `post_id` field, as it will be stored in the table.

Selecting a Comment looks like this:

```golang
comments := &[]Comment{}
query, err := mapper.NewSelect(comments)
if err != nil {
    panic(err)
}
query.Where(Eq("id", 1)).Join("post").All()
```

This query loads `comment` with an appropriate comment, with the data of `Post`, which is a `Message` object.

## Has one

When a struct "has one" another struct, it stores the struct ID at the other struct:

```golang
type User struct {
    ID       int
    Name     string
    Password string
    Profile  *Profile `db:"profile,relation=user"`
}

type Profile struct {
    ID      int
    UserID  int  `db:"user_id"`
    Email   string
}
```

In this case, User "has a" Profile, but Profile doesn't "belong to" User. User requires a reference to a profile, and Profile requieres a `user_id` field. User's Profile field requires an option "relation" with a value how Profile is referencing it.

Selecting a User with profile looks like this:

```golang
users := &[]User{}
query, err := mapper.NewSelect(users)
if err != nil {
    panic(err)
}
query.Where(Eq("id", 1)).Join("profile").All()
```
